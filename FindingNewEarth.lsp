(setq *BR* '(
	("R1" ((equalp TypePlanete "Gazeuse")) ((Habitabilite "NonHabitable")))
	("R2" ((<= RayonEtoile 974400) (>= RayonEtoile 783000)) ((ClasseEtoile "F")))
	("R3" ((< RayonEtoile 783000) (>= RayonEtoile  619440)) ((ClasseEtoile "G")))
	("R4" ((< RayonEtoile 619440) (>= RayonEtoile 556800)) ((ClasseEtoile "K")))
	("R5" ((> RayonEtoile 974400)) ((Habitabilite "NonHabitable")))
	("R6"  ((< RayonEtoile 556800))  ((Habitabilite "NonHabitable")))
	("R7" ((<= MasseEtoile 3.3813) (>= MasseEtoile 2.366)) ((ClasseEtoile "F")))
	("R8" ((< MasseEtoile  2.366) (>= MasseEtoile 1.7)) ((ClasseEtoile "G")))
	("R9" ((< MasseEtoile  1.7) (>= MasseEtoile  1.451)) ((ClasseEtoile "K")))
	("R10" ((> MasseEtoile  3.3813)) ((Habitabilite "NonHabitable")))
	("R11"  ((< MasseEtoile  1.451))  ((Habitabilite "NonHabitable")))
	("R12" ((<= LuminositeEtoile 23.076) (>= LuminositeEtoile 7.23)) ((ClasseEtoile "F")))
	("R13" ((< LuminositeEtoile 7.23) (>= LuminositeEtoile 2.288)) ((ClasseEtoile "G")))
	("R14" ((< LuminositeEtoile  2.288) (>= LuminositeEtoile  1.07)) ((ClasseEtoile "K")))
	("R15" ((> LuminositeEtoile   23.076)) ((Habitabilite "NonHabitable")))
	("R16"  ((< LuminositeEtoile  1.07))  ((Habitabilite "NonHabitable")))
	("R17" ((<= TemperatureEtoile 7240) (> TemperatureEtoile 6000)) ((ClasseEtoile "F")))
	("R18" ((< TemperatureEtoile  6000) (>= TemperatureEtoile 5200)) ((ClasseEtoile "G")))
	("R19" ((< TemperatureEtoile  5200) (>= TemperatureEtoile  4640)) ((ClasseEtoile "K")))
	("R20" ((> TemperatureEtoile  7240)) ((Habitabilite "NonHabitable")))
	("R21" ((< TemperatureEtoile  4640))  ((Habitabilite "NonHabitable")))
	("R22" ((equalp ClasseEtoile "F")) ((RayonEtoile 878700) (MasseEtoile 2.87365) (LuminositeEtoile 15.153) (TemperatureEtoile 6620)))
	("R23" ((equalp ClasseEtoile "G")) ((RayonEtoile 701220) (MasseEtoile 2.033) (LuminositeEtoile 4.759) (TemperatureEtoile 4920)))
	("R24" ((equalp ClasseEtoile "K")) ((RayonEtoile 588120) (MasseEtoile 1.679) (LuminositeEtoile 4.759) (TemperatureEtoile 5600)))
	("R25" ((> DureeJour 14))((JourNuit "Non")))
	("R26" ((> DureeJour 0) (< DureeJour 14)) ((JourNuit "Oui")))
	("R27" ((equalp JourNuit "Non")) ((Habitabilite "NonHabitable")))
	("R28" ((> NbEtoileSysteme 1)) ((TypePlanete "Gazeuse")))
	("R29" ((equalp TypePlanete "Tellurique")) ((NbEtoileSysteme 1)))
	("R30" ((equalp MouvementEtoile "Orbite")) ((NbEtoileSysteme 2)))
	("R31" ((equalp MouvementEtoile "Fixe")) ((NbEtoileSysteme 1)))
	("R32" ((< TemperatureSurface 100) (> TemperatureSurface 0)) ((Eau "liquide")))
	("R33" ((> TemperatureSurface 100)) ((Eau "gazeuse")))
	("R34" ((< TemperatureSurface 0)) ((Habitabilite "Douteux")))
	("R35" ((equalp Eau "gazeuse")) ((Habitabilite "NonHabitable")))
	("R36" ((< MassePlanete 1)) ((CatMassePlanete "Faible")))
	("R37" ((>= MassePlanete 1) (< MassePlanete 10)) ((CatMassePlanete "Moyenne")))
	("R38" ((>= MassePlanete 10)) ((CatMassePlanete "Importante"))) 
	("R39" ((equalp TypeEtoile "NaineJauneBlanche")) ((ClasseEtoile "F")))
	("R40" ((equalp TypeEtoile "NaineJaune")) ((ClasseEtoile "G")))
	("R41" ((equalp TypeEtoile "NaineOrange")) ((ClasseEtoile "K")))
	("R42" ((equalp ClasseEtoile "F")) ((LimHabInf 0.89)))
	("R43" ((equalp ClasseEtoile "G")) ((LimHabInf 0.95)))
	("R44" ((equalp ClasseEtoile "K")) ((LimHabInf 1.22)))
	("R45" ((equalp LimHabInf 0.89)) ((ClasseEtoile "F")))
	("R46" ((equalp LimHabInf 0.95)) ((ClasseEtoile "G")))
	("R47" ((equalp LimHabInf 1.22)) ((ClasseEtoile "K")))
	("R48" ((equalp LimHabInf 0.89)) ((LimHabSup 1.61)))
	("R49" ((equalp LimHabInf 0.95)) ((LimHabSup 1.67)))
	("R50" ((equalp LimHabInf 1.22)) ((LimHabSup 1.94)))
	("R51" ((equalp LimHabSup 1.94)) ((ClasseEtoile "K")))
	("R52" ((equalp LimHabSup 1.67)) ((ClasseEtoile "G")))
	("R53" ((equalp LimHabSup 1.61)) ((ClasseEtoile "F")))
	("R54" ((equalp ClasseEtoile "F") (< DistanceEtoile 0.89)) ((ZoneHab "Avant")))
	("R55" ((equalp ClasseEtoile "F") (> DistanceEtoile 1.61)) ((ZoneHab "Apres")))
	("R56" ((equalp ClasseEtoile "G") (< DistanceEtoile 0.95)) ((ZoneHab "Avant")))
	("R57" ((equalp ClasseEtoile "G") (> DistanceEtoile 1.67)) ((ZoneHab "Apres")))
	("R58" ((equalp ClasseEtoile "K") (< DistanceEtoile 1.22)) ((ZoneHab "Avant")))
	("R59" ((equalp ClasseEtoile "K") (> DistanceEtoile 1.94)) ((ZoneHab "Apres")))
	("R60" ((equalp ClasseEtoile "F") (> DistanceEtoile 0.89) (< DistanceEtoile 1.61))  ((ZoneHab "Dedans")))
	("R61" ((equalp ClasseEtoile "G") (> DistanceEtoile 0.95) (< DistanceEtoile 1.67))  ((ZoneHab "Dedans")))
	("R62" ((equalp ClasseEtoile "K") (> DistanceEtoile 1.22) (< DistanceEtoile 1.94))  ((ZoneHab "Dedans")))
	("R63" ((equalp ZoneHab "Apres")) ((Habitabilite "NonHabitable")))
	("R64" ((equalp ZoneHab "Avant")) ((Habitabilite "NonHabitable")))
	("R65" ((equalp GazeuseAvant "Oui")) ((Atmosphere "Absente")))
	("R66" ((equalp GazeuseApres "Non")) ((Atmosphere "Absente")))
	("R67" ((equalp CatMassePlanete "Moyenne")) ((ChampMag "Present")))
	("R68" ((equalp CatMassePlanete "Importante")) ((ChampMag "Present")))
	("R69" ((equalp CatMassePlanete "Faible")) ((ChampMag "Absent")))
	("R70" ((equalp ChampMag "Absent")) ((Atmosphere "Absente")))
	("R71" ((member Histoire "meteorite") (member Histoire "DegazageV")) ((Atmosphere "Presente")))
	("R72" ((equalp Atmosphere "Absente")) ((Habitabilite "NonHabitable")))
	("R73" ((equalp CatMassePlanete "Faible")) ((CompoAtm '("Carbone" "VapeurEau"))))
	("R74" ((equalp CatMassePlanete "Moyenne")) ((CompoAtm '("Carbone" "Azote" "Oxygene"))))
	("R75" ((equalp CatMassePlanete "Importante")) ((CompoAtm '("Helium" "Hydrogene" "Azote"))))
	("R76" ((member CompoAtm "Helium")) ((Habitabilite "NonHabitable")))
	("R77" ((member SpecialAtm "Ozone")) ((Habitabilite "Habitable")))
	("R78" ((member CompoAtm "Helium")) ((CatMassePlanete "Importante")))
	("R79" ((not (member CompoAtm "Azote"))) ((CatMassePlanete "Faible")))
	("R80" ((member CompoAtm "Azote") (not (member CompoAtm "Helium"))) ((CatMassePlanete "Moyenne")))
	("R81" ((not (member Histoire "meteorite"))) ((Atmosphere "Absente")))
	("R82" ((not (member Histoire "DegazageV"))) ((Atmosphere "Absente")))
	("R83" ((member Histoire "EruptionStellaire")) ((Habitabilite "NonHabitable")))
))


(setq *BF* '())

;Demande la caractéristiques "but" à l'utilisateur
(defun question (but)
	(let ((reponse))
		(print (concatenate 'string "On a besoin du fait " (write-to-string but) " dans notre base de faits pour que ça marche. Tapez NIL si vous ne le connaissez pas."))
		(print '>)
		(setq reponse (read-line))
		(if (OR (numberp (read-from-string reponse)) (AND (NOT (equalp reponse "NIL")) (listp (read-from-string reponse))))
			(pushnew (list but (read-from-string reponse)) *BF*) ;si c'est une liste ou un nombre, il faut enlever les guillemets (sauf autour de NIL même si c'est aussi une liste)
			(pushnew (list but reponse) *BF*)
		)
	)
	NIL
)

;renvoie les premisses d'une règle appelée par son nom
(defun premisses(r)
	(cadr (assoc r *BR* :test #'equal))
)

;renvoie les conclusions d'une règle appelée par son nom
(defun conclusions(r)
	(caddr (assoc r *BR* :test #'equal))
)

;renvoie la valeur d'une caractéristique présente dans la BF
(defun attributBF (attribut)
	(cadr (assoc attribut *BF* :test #'equal))
)

;vérifie si une règle est applicable, càd si ses premisses sont dans la BF
(defun regle_applicable(regle)
	(let ((applicable T))
		(dolist (p (premisses regle))
			(if (equal (car p) 'NOT) ;si il y a un NOT dans la premisse, l'attribut n'est pas situé au même endroit
				(if (NOT (assoc (cadadr p) *BF* :test #'equal))
					(setq applicable NIL)
				)
				(if (NOT (assoc (cadr p) *BF* :test #'equal))
					(setq applicable NIL)
				)
			)
		)
	applicable
	)	
)

;liste les règles qui sont candidates : applicables + les valeurs des caractéristiques vérifient les règles
(defun regles_candidates(BR)
	(let ((retour) (addregle T) (condi))
		(dolist (regle BR)
			(when (regle_applicable (car regle))
				(dolist (prem (premisses (car regle)))
					(cond ;il faut un cond car la mise en place dans la condition n'est pas pareil selon l'opérateur (member, NOT etc...)
						((equalp (attributBF (cadr prem)) "NIL") 
							(setq condi NIL))
						((equal (car prem) 'member) 
							(setq condi (list (car prem) (caddr prem) (attributBF (cadr prem)) ':test #'equal) ))
						((equal (car prem) 'NOT)
							(cond 
								((equalp (attributBF (cadadr prem)) "NIL") (setq condi T)) ;si on a NOT et NIL, on met à T sinon il va considérer la règle est bonne (vu que l'eval doit être NIL)
								((equal (caadr prem) 'member)
									(setq condi (list (caadr prem) (car (cddadr prem)) (attributBF (cadadr prem)) ':test #'equal)))
								(t (setq condi (list (caadr prem)  (attributBF (cadadr prem))(car (cddadr prem)))))
							)
						)
						(t 
							(setq condi (list (car prem)  (attributBF (cadr prem)) (caddr prem))))
					)
					;ensuite on évalue la condition où on a remplacé par la caractéristique par sa valeur dans la BF
					(unless (OR (AND (eval condi) (NOT (equal (car prem) 'NOT))) (AND (NOT (eval condi)) (equal (car prem) 'NOT)))
						(setq addregle NIL)
					)
				)
				(if addregle ;si les premisses sont vérifiés, on garde la règle
					(push (car regle) retour)			
					(setq addregle T)
				)
			)
		)
		(return-from regles_candidates retour)
	)
)

;parcours les règles candidates et gardent celles dont les conclusions ne sont pas déjà dans la BF
(defun regle_nonutilise(BR)
	(let ((regles (regles_candidates BR)) (listeRegle) (nonutilise NIL))
		(dolist (r regles listeRegle)
			(dolist (conclu (conclusions r))
				(if (NOT (assoc (car conclu) *BF*))
					(setq nonutilise T)
					(if (equalp (cadr (assoc (car conclu) *BF*)) "NIL") ;si la conclusion est déjà dans la BF mais vaut NIL, on prend la règle
						(setq nonutilise T)
					)
				)
			)
			(when nonutilise
				(push r listeRegle)
				(setq nonutilise NIL)
			)
		)
	)
)

;vérifie si habitabilite est present dans la BF
(defun appartient_BF ()
	(let ((habitabilite (assoc 'Habitabilite *BF* :test #'equal)))
		(if habitabilite
			(cadr habitabilite)
			nil
		)
	)
)

;applique une règle qui est appelé par son nom. L'application de la règle correspond à l'ajout de ses conclusions dans la BF
(defun appliquer_regle (regle)
	(format t "Application de la règle : ~S ~C" regle #\newline)
	(dolist (conclu (conclusions regle) NIL)
		(if (assoc (car conclu) *BF*)
			(if (equalp (cadr (assoc (car conclu) *BF*)) "NIL")
				(progn ;si la conclusion est déjà la BF mais a pour valeur NIL, on supprime l'ancienne caractéristique et on la remet avec une valeur
					(setq *BF* (delete (assoc (car conclu) *BF*) *BF* :test #'equal))
					(push conclu *BF*)
				)
			)
			(push conclu *BF*)
		)
	)
)

;moteur en chaine avant en profondeur d'abord.
(defun chainage_avant_profondeur()
	(let* ((copy_BR *BR*) (regle (regle_nonutilise copy_BR)) (newregle))
		(while (AND (NOT (appartient_BF)) (OR regle (chercherQuestion copy_BR))) ;tant qu'il y a une règle ou qu'il y a une question et que habitabilite n'est pas dans BF
			(if regle ;si il y a une règle à appliquer on l'applique, sinon on pose une question
				(appliquer_regle (pop regle))
				(question (chercherQuestion copy_BR))
			)
			(setq newregle (regle_nonutilise copy_BR))
			(dolist (R regle) ;on va supprimer les règles qui n'ont plus lieu d'être (dont les conclusions sont déjà dans la BF)
				(if (NOT (member R newregle :test #'equal))
					(setq regle (delete R regle :test #'equal))
				)
			)
			(dolist (R (reverse newregle)) ;et on rajoute au début les nouvelles règles debloqué par l'application d'une règle
				(pushnew R regle)
			)
		)
		
		(cond ;les trois conclusions possibles
			((appartient_BF) (format t "L'habitabilité de la planète est : ~S ~C" (appartient_BF) #\newline))
			((aucunNil) (format t "Cette planète a des chances d'être habitable ! ~C" #\newline))
			(t (format t "On n'en sait pas assez pour déduire si la planète est habitable ou non. ~C" #\newline))
		)
	)
)

;moteur en chaine avant en largeur d'abord
(defun chainage_avant_largeur()
	(let* ((copy_BR *BR*) (regles (regle_nonutilise copy_BR)))
		(while (AND (NOT (appartient_BF)) (OR regles (chercherQuestion copy_BR)))
			(if regles
				(progn
					(dolist (regle regles) ;on applique toutes les règles au lieu de une
						(appliquer_regle regle)
					)
				)
				(question (chercherQuestion copy_BR))
			)
			(setq regles (regle_nonutilise copy_BR))
		)
	
		(cond ;les trois conclusions possibles
			((appartient_BF) (format t "L'habitabilité de la planète est : ~S ~C" (appartient_BF) #\newline))
			((aucunNil) (format t "Cette planète a des chances d'être habitable ! ~C" #\newline))
			(t (format t "On n'en sait pas assez pour déduire si la planète est habitable ou non. ~C" #\newline))
		)
	)
)

;fonction main qui correspond au mini interface
(defun main()
	(let ((saisie_utilisateur) (nomplanete))
		(setq *bf* '())
		(format t "### Bienvenue dans notre système qui vous permettra de savoir si une planète est habitable ou non!###  ~C" #\newline)
		(format t "=============================================================  ~C" #\newline)
		(format t "Veuillez saisir le nom de votre planete : ~C" #\newline)
		(setq nomplanete (read-line)) ;choix du nom de la planète
		(push (list 'NomPlanete nomplanete) *bf*)
		
		(loop
				(format t "============================================================= ~C" #\newline)
				(format t "Pour ajouter une caractéristique à la planète, tapez 1 ~C" #\newline)
				(format t "Pour voir les caractéristiques de votre planète, tapez 2 ~C" #\newline)
				(format t "Pour voir les caractéristiques et les attributs possibles pour votre planetes, tapez 3 ~C" #\newline)
				(format t "Pour mettre les caractéristiques de la terre, tapez 4 ~C" #\newline)
				(format t "Pour mettre les caractéristiques de Mars, tapez 5 ~C" #\newline)
				(format t "Pour vérifier si votre planète a des chances d'être habitable ou non (Profondeur d'abord) , tapez 6 ~C" #\newline)
				(format t "Pour vérifier si votre planète a des chances d'être habitable ou non (Largeur d'abord) , tapez 7 ~C" #\newline)
				(format t "============================================================= ~C" #\newline)
				(format t ">")
				(setq saisie_utilisateur (read-line))
				(cond 
					((equal saisie_utilisateur "1") (add_caract))
					((equal saisie_utilisateur "2") (lister_faits))
					((equal saisie_utilisateur "3") (regles_faits))
					((equal saisie_utilisateur "4") (preconfig1))
					((equal saisie_utilisateur "5") (preconfig2))
					((equal saisie_utilisateur "6") (chainage_avant_profondeur) (return))
					(T (chainage_avant_largeur) (return))
				)
		)
		
		
		(lister_faits) ;affichage des caractéristiques
		"Fin du programme"
	)
)

;ajout d'une caractéristique dans la base de fait par saisie de l'utilisateur
(defun add_caract()
	(let ((caract) (attribut) (attributliste))
		(format t "Faites attention, avant de continuer, vérifier bien les conditions des différentes caractéristiques en tapant 3 dans le menu principale ~C" #\newline)
		(format t "Pour revenir au menu principal, tapez 1, 0 sinon ~C" #\newline)
		(if (equal (read-line) "1")
			(return-from add_caract NIL)
			(progn
				(format t "Saisir le nom de la caractéristique ~C" #\newline)
				(setq caract (read-from-string (read-line)))
				(format t "Saisir la valeur de caractéristique ~C" #\newline)
				(setq attribut (read-line))
				(cond ;si c'est une liste ou un chiffre, on doit enlever les guillemets, comme pour les questions
					((numberp (read-from-string attribut)) (setq attribut (read-from-string attribut)))
					((AND (not (equalp attribut "NIL")) (listp (read-from-string attribut)))
						(setq attribut (read-from-string attribut))
					)
				)
				(pushnew (list caract attribut) *bf*)
			)
		)
		(format t "~C" #\newline)
	)
)

;affiche les différentes caractéristiques et la façon de les écrire.
(defun regles_faits()
	(format t "Voici comment doivent être décrites chacune des propriétés : ~C" #\newline)
	(format t "============================================================= ~C" #\newline)
	(format t "> ClasseEtoile : Seul les étoiles K, F et G sont habitables ~C" #\newline)
	(format t "> TypeEtoile :  : Nom scientifique de l'étoile. Seul les planetes NaineJauneBlanche, NaineJaune et NaineOrange sont habitables.  ~C" #\newline)
	(format t "> TemperatureEtoile : En kelvin.  ~C" #\newline)
	(format t "> RayonEtoile : En kilomètre.  ~C" #\newline)
	(format t "> LuminositéEtoile : En ×10^26 Watts (exemple si 10 ×10^26 W, ne mettre que 10).  ~C" #\newline)
	(format t "> MasseEtoile : 10^30 kg.  ~C" #\newline)
	(format t "> ZoneHab : Trois valeurs avant, dedans ou après ~C" #\newline)
	(format t "> LimHab : Chiffre compris en 0 et 2 environ. Les classes G, F et K ont une limhab entre 0,89 et 1,22 ~C" #\newline)
	(format t "> TypePlanete : Gazeuse ou Tellurique ~C" #\newline)
	(format t "> CompoAtm : Liste de composants, donc entre parenthèse. Ex '(\"Carbone\" \"Helium\") (sans les backslash) ~C" #\newline)
	(format t "> TemperatureSurface : moyenne en degré  ~C" #\newline)
	(format t "> Eau :  Liquide, Gazeuse ou Solide ~C" #\newline)
	(format t "> MassePlanete : en 10^24 kg ~C" #\newline)
	(format t "> LimHabInf et LimHabSup : en UA ~C" #\newline)
	(format t "> NbEtoileSysteme : Plus de 0 ~C" #\newline)
	(format t "> CatMassePlanete : faible (< 1*10^24kg), moyenne (Entre 1*10^24 et 10*10^24) ou importante (> 10*10^24) ~C" #\newline)
	(format t "> GazeuseAvant et GazeuseApres. Savoir si il y a une planète gazeuse plus proche du soleil (GazeuseAvant) ou plus loin (GazeuseApres). Reponse possible : Oui ou Non ~C" #\newline)
	(format t "> ChampMag : present ou absent ~C" #\newline)
	(format t "> Histoire : Sous forme de liste. Notamment meteorite, DegazageV et EruptionStellaire. ex : '(\"meteorite\" \"DegazageV\") ~C" #\newline)
	(format t "> SpecialAtm : Composant spécial de l'atmosphère, notamment Ozone. Sous forme de liste.~C" #\newline)
	
	(format t "============================================================= ~C" #\newline)
	(format t "~C" #\newline)
)

;Met dans la base de faits les caractéristiques de la Terre
(defun preconfig1()
	(setq *bf* '())
	(push '(Nom "Terre") *bf*)
	(push '(TypePlanete "Tellurique") *bf*)
	(push '(ClasseEtoile "G") *bf*)
	(push '(DureeJour 1) *bf*)
	(push '(TemperatureSurface 15) *bf*)
	(push '(MassePlanete 5.9) *bf*)
	(push '(GazeuseAvant "Non") *bf*)
	(push '(GazeuseApres "Oui") *bf*)
	(push '(SpecialAtm '("Ozone")) *bf*)
	(push '(Histoire '("meteorite" "DegazageV")) *bf*)
)

;Met dans la base de faits les caractéristiques de Mars
(defun preconfig2()
	(setq *bf* '())
	(push '(Nom "Mars") *bf*)
	(push '(TypePlanete "Tellurique") *bf*)
	(push '(ClasseEtoile "G") *bf*)
	(push '(DureeJour 1) *bf*)
	(push '(MassePlanete 0.6) *bf*)
	(push '(GazeuseAvant "Non") *bf*)
	(push '(GazeuseApres "Oui") *bf*)
	(push '(Histoire '("meteorite")) *bf*)
)

;vérifie que toutes les caracts dans la base de fait ont une valeur et non pas NIL
(defun aucunNil()
	(dolist (fait *BF* T)
		(if (equalp (cadr fait) "NIL")
			(return-from aucunNil NIL)
		)
	)
)

;recherche une question à poser, c'est-à-dire une caractéristique qui est utile pour débloquer une règle
(defun chercherQuestion(BR)
	(dolist (R BR NIL)
		(when (conclusionabs (car R)) ;seulement les règles dont les conclusions sont absentes dans la base de fait
			(dolist (prem (premisses (car R)))
				(if (equalp (car prem) 'NOT)
					(unless (attributBF (cadadr prem))
						(return-from chercherQuestion (cadadr prem))
					)	
					(unless (attributBF (cadr prem))
						(return-from chercherQuestion (cadr prem))
					)
				)
			)
		)
	)
)

;affiche les caractéristiques de la planète
(defun lister_faits ()
	(write-line "")
	(write-line "*****Caractéristique de votre planète****")
	(dolist (f (reverse *bf*))
		(if (numberp (cadr f))
			(write-line (concatenate 'string (symbol-name (car f)) " : " (write-to-string (cadr f))))
			(if (NOT (listp (cadr f)))
				(write-line (concatenate 'string (symbol-name (car f)) " : " (cadr f)))
				(write-line (concatenate 'string (symbol-name (car f)) " : " (write-to-string (cadadr f))))	
			)
		)
	)
	(format t "~C" #\newline)
)

;vérifie que les conclusions de la règle ne sont pas dans la base de fait.
(defun conclusionabs (regle)
	(let ((presence NIL))
		(dolist (conclu (conclusions regle) presence)
			(if (NOT (assoc (car conclu) *BF*))
				(setq presence T)
			)
		)
	)
)

